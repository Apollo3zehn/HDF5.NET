<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<# 
	using var webClient = new WebClient();

    var url1 = "https://raw.githubusercontent.com/Blosc/c-blosc/master/blosc/shuffle-sse2.c";
    var csstring = webClient.DownloadString(url1); 
    
    var url2 = "https://raw.githubusercontent.com/Blosc/c-blosc/master/LICENSES/BLOSC.txt";
    var license = webClient.DownloadString(url2);

    // decoration and type definitions
    csstring = Regex.Replace(csstring, @"#.*", "");
    csstring = Regex.Replace(csstring, @"static void\n", "private static unsafe void ");
    csstring = Regex.Replace(csstring, @"void\n", "private static unsafe void ");
    csstring = Regex.Replace(csstring, @"const\s", "");
    csstring = Regex.Replace(csstring, @"const\s", "");
    csstring = Regex.Replace(csstring, @"size_t\s", "ulong ");
    csstring = Regex.Replace(csstring, @"uint8_t\*", "byte*");
    csstring = Regex.Replace(csstring, @"inline ", "");
    csstring = Regex.Replace(csstring, @"static ulong", "ulong");
    csstring = Regex.Replace(csstring, @"sizeof\(__m128i\)", "sizeof(Vector128<byte>)");
    csstring = Regex.Replace(csstring, @"__m128i\s", "var ");
    csstring = Regex.Replace(csstring, @"\(__m128i\*\)", "");
    csstring = Regex.Replace(csstring, @"var xmm0\[(.*)\], xmm1\[(.*)\];", m => $"var xmm0 = new Vector128<byte>[{m.Groups[1]}];\n  var xmm1 = new Vector128<byte>[{m.Groups[1]}];");
    csstring = Regex.Replace(csstring, @"var xmm1\[(.*)\], xmm2\[(.*)\];", m => $"var xmm1 = new Vector128<byte>[{m.Groups[1]}];\n  var xmm2 = new Vector128<byte>[{m.Groups[1]}];");
    csstring = Regex.Replace(csstring, @"\+= sizeof\(Vector128<byte>\)", "+= (ulong)sizeof(Vector128<byte>)");
    csstring = Regex.Replace(csstring, @"\* sizeof\(Vector128<byte>\)", "* (ulong)sizeof(Vector128<byte>)");
    csstring = Regex.Replace(csstring, @"int j;", "uint j;");
    csstring = Regex.Replace(csstring, @"int k;", "uint k;");
    csstring = Regex.Replace(csstring, @"int k, l;", "uint k; int l;");
    
    csstring = Regex.Replace(csstring, @"unshuffle_generic_inline", "ShuffleGeneric.Unshuffle");
    csstring = Regex.Replace(csstring, @"shuffle_generic_inline", "ShuffleGeneric.Shuffle");
    csstring = Regex.Replace(csstring, @"blosc_internal_unshuffle_generic\(bytesoftype", "ShuffleGeneric.Unshuffle(bytesoftype, 0");
    csstring = Regex.Replace(csstring, @"blosc_internal_shuffle_generic\(bytesoftype", "ShuffleGeneric.Shuffle(bytesoftype, 0");
    csstring = Regex.Replace(csstring, @"default:.*?}.*?}", "throw new Exception(\"No optimized SSE Implementation found.\");", RegexOptions.Singleline);

    // intrinsics
    csstring = Regex.Replace(csstring, @"_mm_loadu_si128", "Sse2.LoadVector128");
    csstring = Regex.Replace(csstring, @"_mm_storeu_si128", "Sse2.Store");
    csstring = Regex.Replace(csstring, @"_mm_shuffle_epi32\((.*?), (.*?)\)", m => $"Sse2.Shuffle({m.Groups[1]}.AsInt32(), {m.Groups[2]}).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_shufflelo_epi16\((.*?), (.*?)\)", m => $"Sse2.ShuffleLow({m.Groups[1]}.AsInt16(), {m.Groups[2]}).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_shufflehi_epi16\((.*?), (.*?)\)", m => $"Sse2.ShuffleHigh({m.Groups[1]}.AsInt16(), {m.Groups[2]}).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_unpacklo_epi8", "Sse2.UnpackLow");
    csstring = Regex.Replace(csstring, @"_mm_unpackhi_epi8", "Sse2.UnpackHigh");
    csstring = Regex.Replace(csstring, @"_mm_unpacklo_epi16\((.*?), (.*?)\)", m => $"Sse2.UnpackLow({m.Groups[1]}.AsInt16(), {m.Groups[2]}.AsInt16()).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_unpacklo_epi64\((.*?), (.*?)\)", m => $"Sse2.UnpackLow({m.Groups[1]}.AsInt64(), {m.Groups[2]}.AsInt64()).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_unpackhi_epi64\((.*?), (.*?)\)", m => $"Sse2.UnpackHigh({m.Groups[1]}.AsInt64(), {m.Groups[2]}.AsInt64()).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_unpacklo_epi32\((.*?), (.*?)\)", m => $"Sse2.UnpackLow({m.Groups[1]}.AsInt32(), {m.Groups[2]}.AsInt32()).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_unpackhi_epi32\((.*?), (.*?)\)", m => $"Sse2.UnpackHigh({m.Groups[1]}.AsInt32(), {m.Groups[2]}.AsInt32()).AsByte()");
    csstring = Regex.Replace(csstring, @"_mm_unpackhi_epi16\((.*?), (.*?)\)", m => $"Sse2.UnpackHigh({m.Groups[1]}.AsInt16(), {m.Groups[2]}.AsInt16()).AsByte()");
     

    // remove unnecessary blocks
    csstring = Regex.Replace(csstring, @"/\*.*?Author.*?\\*}", "", RegexOptions.Singleline);
    csstring = Regex.Replace(csstring, @"/\* The next is useful for debugging purposes \*/.*?}", "", RegexOptions.Singleline);
    csstring = Regex.Replace(csstring, @"/\* GCC doesn't include the split load/store intrinsics.*?}.*?}", "", RegexOptions.Singleline);
    csstring = Regex.Replace(csstring, @"/\* Routine optimized for shuffling a buffer for a type size larger than 16 bytes. \*/.*?}\n}", "\n", RegexOptions.Singleline);
    csstring = Regex.Replace(csstring, @"/\* Routine optimized for unshuffling a buffer for a type size larger than 16 bytes. \*/.*?}\n}", "\n", RegexOptions.Singleline);

    // line breaks
    csstring = Regex.Replace(csstring, @"(\n){3,}", "\n\n");
    csstring += "\n";

    // tabs
    //csstring = Regex.Replace(csstring, @"^\s{2}(?=[^\s])", "\n     avx   ");
    csstring = Regex.Replace(csstring, @"\n\s{0}(?=[^\s])", "\n        ");
    csstring = Regex.Replace(csstring, @"\n\s{2}(?=[^\s])", "\n            ");
    csstring = Regex.Replace(csstring, @"\n\s{4}(?=[^\s])", "\n                ");
    csstring = Regex.Replace(csstring, @"\n\s{5}(?=[^\s])", "\n             ");
    csstring = Regex.Replace(csstring, @"\n\s{6}(?=[^\s])", "\n                    ");
#>
/* 
This is automatically translated code from https://github.com/Blosc/c-blosc

<# Write(license); #> 
*/

#if NETCOREAPP3_0

using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

namespace HDF5.NET
{
    public static class ShuffleSse2
    {
        <# Write(csstring); #>
    }
}

#endif